UNICODE_WHITE = _{ "\u{FEFF}" | "\u{2060}" | "\u{200B}" | "\u{00A0}" }
RESERVED_CHAR =
 _{ '\x00'..'\x1F'
  | WHITE_SPACE
  | ":" | ";" | "`" | "\"" | "'" | "@" | "#" | "." | ","
  | "|" | "^" | "&" | "<" | "=" | ">" | "+" | "-" | "*" | "/"
  | "\\" | "%" | "?" | "!" | "~" | "(" | ")" | "[" | "]" | "{" | "}"
  | UNICODE_WHITE
  }
RESERVED_CHAR_WITH_NUM = _{ RESERVED_CHAR | '0'..'9' }
UNICODE_CHAR =
 _{ "\\u" ~ ('0'..'9' | 'a' ..'f' | 'A'..'F'){4}
  | "\\u{" ~ ('0'..'9' | 'a'..'f' | 'A' ..'F')+ ~ "}"
  }
ALPHA = _{ (!RESERVED_CHAR ~ ANY) | UNICODE_CHAR  }
ALNUM = _{ (!RESERVED_CHAR_WITH_NUM ~ ANY) | UNICODE_CHAR }

LINE_COMMENT = _{ "//" ~ (!NEWLINE ~ ANY)* }
BLOCK_COMMENT =
 _{ "/*"
  ~ (!"*" ~ ANY)*
  ~ "*"+
  ~ ((!("/" | "*") ~ ANY) ~ (!"*" ~ ANY)* ~ "*"+)*
  ~ "/"
  }
COMMENT =
 _{ LINE_COMMENT
  | BLOCK_COMMENT
  }

EXTRAS =
 _{ WHITE_SPACE
  | NEWLINE
  | UNICODE_WHITE
  | COMMENT
  }

program = { EXTRAS* ~ declaration* ~ EXTRAS* }

declaration =
  { function_declaration
  | class_declaration
  | type_alias_declaration
  }

function_declaration =
  { "function" ~ identifier ~ declaration_signature ~ statement_block
  }

class_declaration = { "class" ~ identifier ~ class_heritage? ~ class_body }

class_heritage = { "extends" ~ identifier }

class_body = { "{" ~ (method_definition | field_definition)*  ~ "}" }

method_definition = { property_name ~ declaration_signature ~ statement_block }

field_definition = { property_name ~ initializer? }

property_name = { identifier | string | number }

initializer = { "=" ~ expression }

type_alias_declaration = { "type" ~ identifier ~ "=" ~ type_scheme ~ ";" }

declaration_signature =
  { "(" ~ (formal_parameter ~ ("," ~ formal_parameter)*)? ~ ")"
  }

formal_parameter = { identifier ~ ":" ~ type_expression }

statement_block = { "{" ~ statement? ~ "}" }

statement =
 { lexical_declaration
 | if_statement
 | switch_statement // pattern matching
 | try_statement // checked exceptions
 | do_statement // do-notation
 | return_statement
 | throw_statement
 }

lexical_declaration =
  { "const"
  ~ (variable_declarator ~ ("," ~ variable_declarator)*)
  ~ ";"
  ~ statement
  }

variable_declarator = { identifier ~ initializer }

if_statement =
  { "if" ~ parenthesized_expression ~ statement_block ~ else_clause? }

else_clause = { "else" ~ statement_block }

switch_statement = { "switch" ~ parenthesized_expression ~ switch_body }

switch_body = { "{" ~ (switch_case | switch_default)* ~ "}" }

switch_case = { "case" ~ expression ~ ":" ~ statement* }

switch_default = { "default" ~ ":" ~ statement* }

try_statement = { "try" ~ statement_block ~ catch_clause* }

catch_clause =
  { "catch"
  ~ "("
  ~ identifier
  ~ (":" ~ type_expression)?
  ~ ")"
  ~ statement_block
  }

do_statement =
  { "do" ~ statement_block ~ "while" ~ parenthesized_expression ~ ";"
  }

return_statement = { "return" ~ expression? }

throw_statement = { "throw" ~ expression? }

expression =
  { primary_expression
  | unary_expression
  | binary_expression
  | ternary_expression
  | new_expression
  }

primary_expression =
  { subscript_expression
  | member_expression
  | parenthesized_expression
  | identifier
  | "this"
  | "super"
  | number
  | string
  | regex
  | "false"
  | "true"
  | object
  | array
  | arrow_function
  | call_expression
  }

subscript_expression = { expression ~ "[" ~ expression ~ "]" }

member_expression = { (expression | primary_expression) ~ "." ~ identifier }

parenthesized_expression = { "(" ~ expression ~ ")" }

identifier = { ALPHA ~ ALNUM* }

number =
  { hex_literal
  | binary_literal
  | octal_literal
  | DECIMAL_NUMBER
  | binary_literal
  }

hex_literal =
 _{ ("0x" | "0X")
  ~ ASCII_HEX_DIGIT ~ ("_"? ~ ASCII_HEX_DIGIT)*
  }

binary_literal =
 _{ ("0b" | "0B")
  ~ ASCII_BIN_DIGIT ~ ("_"? ~ ASCII_BIN_DIGIT)*
  }

octal_literal =
 _{ ("0o" | "0O")
  ~ ASCII_OCT_DIGIT ~ ("_"? ~ ASCII_OCT_DIGIT)*
  }

bigint_literal =
 _{ (hex_literal | binary_literal | octal_literal | DECIMAL_NUMBER)
  ~ "n"
  }

string =
  { "\"" ~ unescaped_string* ~ "\""
  | "'" ~ (unescaped_single_string_fragment | escape_sequence)* ~ "'"
  }

unescaped_string = _{ unescaped_double_string_fragment | escape_sequence }

unescaped_double_string_fragment = _{ (!("\"" | "\\") ~ ANY)+ }

unescaped_single_string_fragment = _{ (!("'" | "\\") ~ ANY)+ }

escape_sequence =
 _{ "\\"
  ~ ( !("x" | "u" | '0'..'7')
    | ('0'..'7'){1,3}
    | "x" ~ ('0'..'9' | 'a'..'f' | 'A'..'F'){2}
    | "u" ~ ('0'..'9' | 'a'..'f' | 'A'..'F'){4}
    | "u" ~ "{" ~ ('0'..'9' | 'a'..'f' | 'A'..'F')+ ~ "}"
    )
  }

regex =
 _{ "/"
  ~ regex_pattern
  ~ "/"
  ~ regex_flags?
  }

regex_pattern =
 _{ ( "[" ~ ("\\" ~ ANY | (!("]" | NEWLINE | "\\") ~ ANY))* ~ "]"
    | "\\" ~ ANY
    | (!("/" | "\\" | "[" | NEWLINE) ~ ANY)
    )+
  }

regex_flags = _{ ('a'..'z')+ }

object = { "{" ~ (object_body ~ ("," ~ object_body)*)? ~ "}" }

object_body = { pair | method_definition | identifier }

pair = { property_name ~ ":" ~ expression }

array = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }

arrow_function =
  { (identifier | declaration_signature )
  ~ "=>"
  ~ (expression | statement_block)
  }

call_expression = { expression ~ arguments }

unary_expression = { ("!" | "~" | "-" | "+") ~ expression }

binary_expression =
  { expression
  ~ ( "**" | "*" | "/" | "%"
    | ">>" | ">>>" | "<<"
    | "+" | "-"
    | "<" | "<=" | "==" | "!=" | ">=" | ">"
    | "&&" | "&" | "||" | "|" | "^"
    )
  ~ expression
  }

ternary_expression = { expression ~ "?" ~ expression ~ ":" ~ expression }

new_expression = { "new" ~ identifier ~ arguments }

arguments = { "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

type_scheme = { (identifier ~ ("," ~ identifier)* ~ "=>")? ~ type_expression }

type_expression = { type_term ~ ("->" ~ type_term)* }

type_term =
  { record_type
  | variant_type
  | array_type
  | tuple_type // sugar for records
  | "string"
  | "number"
  | "boolean"
  | "bigint"
  | identifier
  }

record_type =
  { "{}"
  | "{" ~ ("..." | record_field ~ ("," ~ record_field)* ~ ("," ~ "...")? )
  }

record_field = { identifier ~ ":" ~ type_expression }

variant_type =
  { "`|" ~ "..."?
  | variant_field ~ ("," ~ variant_field)* ~ ("|" ~ "...")?
  }

variant_field = { "`" ~ identifier ~ ":" ~ type_expression }

array_type = { "[" ~ type_expression ~ "]" }

tuple_type = { "()" | "(" ~ type_expression ~ ("," ~ type_expression)* ~ ")" }
